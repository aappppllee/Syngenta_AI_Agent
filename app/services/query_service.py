import logging
import uuid # For generating session IDs if not provided
from typing import Dict, Any

from agent.core import AgentCore
from app.models.request_models import QueryRequest
from app.models.response_models import QueryResponse, AnswerDetail
from app.models.db_models import SystemUser # For type hinting current_user
from app.config import settings # For DEBUG_MODE

logger = logging.getLogger(__name__)

class QueryService:
    """
    Service layer for handling query processing logic.
    It acts as an intermediary between the API router and the AgentCore.
    """
    def __init__(self, agent_core: AgentCore): # AgentCore instance injected
        self.agent_core = agent_core
        logger.info("QueryService initialized.")

    async def process_query(self, request: QueryRequest, current_user: SystemUser) -> QueryResponse:
        """
        Processes a user's query by invoking the AgentCore and formatting the response.

        Args:
            request (QueryRequest): The validated query request from the API.
            current_user (SystemUser): The authenticated user making the request.

        Returns:
            QueryResponse: The structured response to be sent back to the client.
        """
        user_context: Dict[str, Any] = {
            "user_id": current_user.user_id,
            "username": current_user.username,
            "role_name": current_user.role.role_name if current_user.role else "Unknown",
            "assigned_region": current_user.assigned_region
        }
        
        # Ensure session_id is present for the AgentCore
        session_id_to_use = request.session_id if request.session_id else str(uuid.uuid4())
        if not request.session_id:
            logger.info(f"QueryService: No session_id in request for user '{current_user.username}', generated new: {session_id_to_use}")

        logger.info(f"QueryService: Processing query '{request.query_text}' for user '{current_user.username}', session '{session_id_to_use}'.")

        try:
            # Call the agent core to handle the query
            # AgentCore.handle_query should return a dict that matches AnswerDetail structure + session_id
            agent_response_dict = await self.agent_core.handle_query(
                query_text=request.query_text,
                user_context=user_context,
                session_id=session_id_to_use 
            )
            
            # agent_response_dict is expected to be the content for the 'answer' field of QueryResponse
            # and also contain the session_id used/generated by AgentCore (which should be session_id_to_use)
            
            # Ensure the 'answer' part (agent_response_dict) can be validated by AnswerDetail
            # The session_id for the outer QueryResponse is session_id_to_use.
            # AgentCore's returned dict is directly used for the 'answer' field.
            
            answer_detail_model = AnswerDetail(**agent_response_dict) # Validate agent's core response part

            query_response = QueryResponse(
                query_text=request.query_text,
                answer=answer_detail_model,
                session_id=session_id_to_use, # Use the managed session_id for the overall response
                follow_up_suggestions=agent_response_dict.get("follow_up_suggestions") # If agent provides them
            )
            logger.info(f"QueryService: Successfully generated response for query from '{current_user.username}'.")
            return query_response
            
        except Exception as e:
            logger.error(f"QueryService: Error processing query for user '{current_user.username}': {e}", exc_info=settings.DEBUG_MODE)
            # Return a generic error response, actual HTTP status handled by global exception handler
            # or specific HTTPException raised from AgentCore if it's an expected error type.
            # This structure should align with what QueryResponse expects for its 'answer' field.
            error_answer = AnswerDetail(
                type="error_service_layer",
                content="An internal error occurred in the query service.",
                summary="Service error",
                explanation=str(e) if settings.DEBUG_MODE else "Internal error."
            )
            return QueryResponse(
                query_text=request.query_text,
                answer=error_answer,
                session_id=session_id_to_use # Still return session_id
            )
